'use strict';class AtlasStitcher{constructor(a){this.canvas=a;this.ctx=this.canvas.getContext("2d")}draw(a,b,c){const f=a.height,h=a.width;var e=b.width;const g=b.height,k=c.padding;c=c.cellSize;const d=c-2*k,l=e+d-1-(e+d-1)%d,m=g+d-1-(g+d-1)%d;this.canvas.width=e;this.canvas.height=g;this.ctx.clearRect(0,0,e,g);e=0;for(const n of b.cellIndexList){if(n!=b.transparentIndex){const p=e%(l/d)*d,q=m-d*(1+intdiv(e,l/d))-(m-g),r=n%(h/c)*c+k,t=f-c*(1+intdiv(n,h/c))+k;this.ctx.drawImage(a,r,t,d,d,p,q,d,d)}e++}}}async function getJson(a){return await Promise.all(a.map(b=>fetch(`/cdn/MonoBehaviour/${b}.json`)))}async function collectSprites(a,b){const c={};for(const f of a){if(200!=f.status){console.log(f);continue}a=await f.json();const h=a.m_Name;c[h]=a;for(const e of a.textureDataList)b.add(new Option(e.name,`${h}:${e.name}`))}return c}const atlasObserver=new IntersectionObserver((a,b)=>{a.forEach(c=>{c.isIntersecting&&(atlasHandler(c.target),b.unobserve(c.target))})});function addAprilFoolSprite(a,b){a=a[0].split("_")[1];a=aprilFoolSpriteMap[a];void 0!==a&&(a=`${APRIL_FOOL}:${a}`,b.prepend(new Option(APRIL_FOOL,a)),b.value=a)}async function atlasHandler(a){const b=a.dataset.sprites.split(","),c=a.querySelector("canvas"),f=a.querySelector("select");a=await getJson(b);const h=await collectSprites(a,f),e=new AtlasStitcher(c);f.addEventListener("change",()=>{const g=f.value.split(":"),k=h[g[0]],d=k.textureDataList.find(m=>m.name==g[1]),l=new Image;l.onload=()=>{e.draw(l,d,k)};l.src=`/cdn/Texture2D/${d.atlasName}.png`});f.dispatchEvent(new Event("change"))}document.querySelectorAll(".atlas-gallery").forEach(a=>atlasObserver.observe(a));function intdiv(a,b){return Math.floor(a/b)};